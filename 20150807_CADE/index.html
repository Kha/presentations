<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>The Lean Theorem Prover</title>
<meta name="author" content="((link (:type http :path //leodemoura.github.io :raw-link http://leodemoura.github.io :application nil :search-option nil :begin 1 :end 72 :contents-begin 32 :contents-end 70 :post-blank 0 :parent #0) Leonardo de Moura (Microsoft Research)) ,  (export-snippet (:back-end html :value <br> :begin 74 :end 88 :post-blank 1 :parent #0)) Soonho Kong (CMU), Jeremy Avigad (CMU),  (export-snippet (:back-end html :value <br> :begin 128 :end 142 :post-blank 1 :parent #0)) Floris van Doorn (CMU), Jakob von Raumer (KIT),  (export-snippet (:back-end html :value <br> :begin 190 :end 204 :post-blank 1 :parent #0)) Rob Lewis (CMU), Haitao Zhang,  (export-snippet (:back-end html :value <br> :begin 235 :end 249 :post-blank 1 :parent #0)) Daniel Selsam (Stanford))"/>

<link rel="stylesheet" href="//leanprover.github.io/presentations/reveal.js-3.0.0/css/reveal.css"/>
<link rel="stylesheet" href="//leanprover.github.io/presentations/reveal.js-3.0.0/css/theme/soonho.css" id="theme"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '//leanprover.github.io/presentations/reveal.js-3.0.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/snap.svg/0.3.0/snap.svg-min.js"></script>
<script type="text/javascript">MathJax.Hub.Config({"HTML-CSS": {scale: 80 }})</script>
<script src="//cdn.jsdelivr.net/polymer.platform/0.4.2/platform.js"></script>
<link rel="import" href="./juicy-ace-editor.html">
<link rel="stylesheet" href="../css/code.css">
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<h1 id='title-name'>The Lean Theorem Prover</h1>
<h2 id='author-list'><a href="http://leodemoura.github.io">Leonardo de Moura (Microsoft Research)</a>, <br> Soonho Kong (CMU), Jeremy Avigad (CMU), <br> Floris van Doorn (CMU), Jakob von Raumer (KIT), <br> Rob Lewis (CMU), Haitao Zhang, <br> Daniel Selsam (Stanford)</h2>
<h2 id='date'>CADE, 2015/08/07 <br> <a href="http://leanprover.github.io">http://leanprover.github.io</a></h2>
</section>

<section id="sec-1" >

<h2>Many thanks to</h2>
<ul class="org-ul">
<li>Cody Roux
</li>
<li>Georges Gonthier
</li>
<li>Grant Passmore
</li>
<li>Nikhil Swamy
</li>
<li>Assia Mahboubi
</li>
<li>Bas Spitters
</li>
<li>Steve Awodey
</li>
<li>Ulrik Buchholtz
</li>
<li>Tom Ball
</li>
<li>Parikshit Khanna
</li>
</ul>

</section>
<section id="sec-2" >

<h2>Introduction: <b>Lean</b></h2>
<ul class="org-ul">
<li>New <b>open source</b> theorem prover
</li>
<li>Platform for
<ul class="org-ul">
<li><b>Software</b> verification &amp; development
</li>
<li>Formalized <b>mathematics</b>
</li>
<li><b>Education</b> (mathematics, logic, computer science)
</li>
<li><b>Synthesis</b> (proofs &amp; programs)
</li>
</ul>
</li>
<li>de Bruijn's Principle: <b>small trusted kernel</b>
</li>
<li>Expressive logic based on <b>dependent type theory</b>
</li>
<li>Partial constructions: automation fills the "holes"
</li>
</ul>

</section>
<section id="sec-3" >

<h2>Introduction: <b>Lean</b></h2>
<ul class="org-ul">
<li>It is an ongoing and <b>long long term</b> effort
</li>
<li>At CMU, it is already being used for formalizing
<ul class="org-ul">
<li>Homotopy Type Theory
</li>
<li>Category Theory
</li>
<li>Algebraic Hierarchy
</li>
<li><a href="https://github.com/javra/msc-thesis">Nonabelian Algebraic Topology</a>
</li>
<li>Number Theory
</li>
</ul>
</li>
<li><a href="http://leanprover.github.io/tutorial">Interactive theory proving course</a> at CMU
</li>
<li>Haitao Zhang is formalizing <a href="https://github.com/leanprover/lean/blob/master/library/theories/group_theory/group_theory.md">Group Theory</a>
</li>
<li>Floris van Doorn implemented <a href="https://github.com/fpvandoorn/leansnippets/blob/master/propositional_truncation.hlean">propositional truncation as a non-recursive HIT</a>
</li>
</ul>

</section>
<section id="sec-4" >

<h2>Main Goal</h2>
<p>
<b>Lean aims to bring two worlds together</b>
</p>

<ul class="org-ul">
<li>An interactive theorem prover with powerful automation
</li>
<li>An automated reasoning tool that
<ul class="org-ul">
<li>produces (detailed) proofs,
</li>
<li>has a rich language,
</li>
<li>can be used interactively, and
</li>
<li>is built on a verified mathematical library
</li>
</ul>
</li>
</ul>

</section>
<section id="sec-5" >

<h2>Secondary Goals</h2>
<ul class="org-ul">
<li><b>Minimalist</b> and <b>high-performace</b> kernel
</li>

<li><b>Experiment</b> with different flavors of type theory
<ul class="org-ul">
<li>Proof irrelevant vs Proof relevant
</li>
<li>Impredicative vs Predicative
</li>
<li>Higher Inductive Types
</li>
<li>Quotient Types
</li>
<li>Observational Type Theory
</li>
</ul>
</li>

<li><b>Have Fun</b>
</li>
</ul>

</section>
<section id="sec-6" >

<h2>What is new?</h2>
<ul class="org-ul">
<li>Poweful <b>elaboration engine</b> that can handle
<ul class="org-ul">
<li>Higher-order unification
</li>
<li>Definitional reductions
</li>
<li>Coercions
</li>
<li>Ad-hoc polymorphism (aka overloading)
</li>
<li>Type classes
</li>
<li>Tactics
</li>
</ul>
</li>
</ul>

<blockquote nil>
<p>
"By relieving the brain of all unnecessary work, a good notation sets it free to
 concentrate on more advanced problems, and in effect increases the mental power of the
 race."
     &#x2013; A. N. Whitehead
</p>
</blockquote>

</section>
<section id="sec-7" >

<h2>What is new?</h2>
<ul class="org-ul">
<li>Poweful <b>elaboration engine</b> that can handle
</li>
<li>Small <b>trusted</b> kernel
<ul class="org-ul">
<li>It does <b>not</b> contain
<ul class="org-ul">
<li>Termination checker
</li>
<li>Fixpoint operators
</li>
<li>Pattern matching
</li>
<li>Module management
</li>
</ul>
</li>
<li><a href="https://github.com/leanprover/tc">Reference type checker</a>
<ul class="org-ul">
<li>Implemented by Daniel Selsam
</li>
<li>&lt; 2000 lines of Haskell code
</li>
<li>Code is easy to read and understand
</li>
<li>Type check the whole standard library (35K lines) under 2 mins
</li>
</ul>
</li>
<li>All Lean files can be exported in a very simple format
<ul class="org-ul">
<li><a href="https://github.com/leanprover/lean/blob/master/doc/export_format.md">Documentation is available on github</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</section>
<section id="sec-8" >

<h2>What is new?</h2>
<ul class="org-ul">
<li>Poweful <b>elaboration engine</b> that can handle
</li>
<li>Small <b>trusted</b> kernel
</li>
<li>Multi-core support
<ul class="org-ul">
<li>Process theorems in parallel
</li>
<li>Execute/try tactics (automation) in parallel
</li>
</ul>
</li>
</ul>

</section>
<section id="sec-9" >

<h2>What is new?</h2>
<ul class="org-ul">
<li>Poweful <b>elaboration engine</b> that can handle
</li>
<li>Small <b>trusted</b> kernel
</li>
<li>Multi-core support
</li>
<li>Fast <b>incremental compilation</b>
</li>
</ul>

</section>
<section id="sec-10" >

<h2>What is new?</h2>
<ul class="org-ul">
<li>Poweful <b>elaboration engine</b> that can handle
</li>
<li>Small <b>trusted</b> kernel
</li>
<li>Multi-core support
</li>
<li>Fast <b>incremental compilation</b>
</li>
<li>Support for mixed <b>declarative</b> and <b>tactic</b> proof style
</li>
</ul>

</section>
<section id="sec-11" >

<h2>What is new?</h2>
<ul class="org-ul">
<li>Poweful <b>elaboration engine</b> that can handle
</li>
<li>Small <b>trusted</b> kernel
</li>
<li>Multi-core support
</li>
<li>Fast <b>incremental compilation</b>
</li>
<li>Support for mixed <b>declarative</b> and <b>tactic</b> proof style
</li>
<li><b>Quotient types</b>
</li>
</ul>

</section>
<section id="sec-12" >

<h2>Architecture</h2>
<img src="./img/framework2.png" alt="framework2.png" height="600px" />


</section>
<section id="sec-13" >

<h2>Two official libraries</h2>
<ul class="org-ul">
<li><b>Standard</b>
<ul class="org-ul">
<li>Proof irrelevant and impredicative Prop
</li>
<li>Smooth transition to classical logic
</li>
<li>Inductive Families
</li>
<li>Quotient Types
</li>
</ul>
</li>

<li><b>HoTT</b>
<ul class="org-ul">
<li>Proof relevant and no impredicative Prop
</li>
<li>Univalence axiom
</li>
<li>Inductive Families
</li>
<li>HIT
</li>
</ul>
</li>

<li>Easy to implement experimental versions,
Example: <a href="https://github.com/leanprover/lean/issues/523">Steve Awodey asked for proof relevant and impredicative universe</a>
</li>
</ul>


</section>
<section id="sec-14" >

<h2>Recursive equations</h2>
<ul class="org-ul">
<li><b>Recursors</b> are <b>inconvenient</b> to use.
</li>
<li>Compiler from <b>recursive equations</b> into <b>recursors</b>.
</li>
<li>Two compilation strategies: <b>structural</b> and <b>well-founded</b> recursion
</li>
</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">definition fib : nat → nat
| fib 0     := 1
| fib 1     := 1
| fib (a+2) := fib (a+1) + fib a

example (a : nat) : fib (a+2) = fib (a+1) + fib a :=
rfl
</juicy-ace-editor>
</div>

</section>
<section id="sec-15" >

<h2>Recursive equations</h2>
<ul class="org-ul">
<li>Dependent pattern matching
</li>
</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">definition map {A B C : Type} (f : A → B → C)
     : Π {n : nat}, vector A n → vector B n → vector C n
| map nil     nil     := nil
| map (a::va) (b::vb) := f a b :: map va vb

definition zip {A B : Type}
     : Π {n}, vector A n → vector B n → vector (A × B) n
| zip nil nil         := nil
| zip (a::va) (b::vb) := (a, b) :: zip va vb
</juicy-ace-editor>
</div>

</section>
<section id="sec-16" >

<h2>Human-readable proofs</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">import algebra.category
open eq.ops category functor natural_transformation

variables {ob₁ ob₂ : Type} {C : category ob₁}
	  {D : category ob₂} {F G H : C ⇒ D}
definition nt_compose (η : G ⟹ H) (θ : F ⟹ G) : F ⟹ H :=
natural_transformation.mk
  (take a, η a ∘ θ a)
  (take a b f, calc
    H f ∘ (η a ∘ θ a) = (H f ∘ η a) ∘ θ a : assoc
		  ... = (η b ∘ G f) ∘ θ a : naturality
		  ... = η b ∘ (G f ∘ θ a) : assoc
		  ... = η b ∘ (θ b ∘ F f) : naturality
		  ... = (η b ∘ θ b) ∘ F f : assoc
</juicy-ace-editor>
</div>

</section>
<section id="sec-17" >

<h2>Human-readable proofs</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">definition infinite_primes (n : nat) : {p | p ≥ n ∧ prime p} :=
let m := fact (n + 1) in
have m ≥ 1,     from le_of_lt_succ (succ_lt_succ (fact_pos _)),
have m + 1 ≥ 2, from succ_le_succ this,
obtain p `prime p` `p ∣ m + 1`, from sub_prime_and_dvd this,
have p ≥ 2,     from ge_two_of_prime `prime p`,
have p &gt; 0,     from lt_of_succ_lt (lt_of_succ_le `p ≥ 2`),
have p ≥ n,     from by_contradiction
  (suppose ¬ p ≥ n,
    have p &lt; n,     from lt_of_not_ge this,
    have p ≤ n + 1, from le_of_lt (lt.step this),
    have p ∣ m,      from dvd_fact `p &gt; 0` this,
    have p ∣ 1,      from dvd_of_dvd_add_right (!add.comm ▸ `p ∣ m + 1`) this,
    have p ≤ 1,     from le_of_dvd zero_lt_one this,
    absurd (le.trans `2 ≤ p` `p ≤ 1`) dec_trivial),
subtype.tag p (and.intro this `prime p`)
</juicy-ace-editor>
</div>

</section>
<section id="sec-18" >

<h2>Structures</h2>
<ul class="org-ul">
<li>Special kind of inductive datatype (only one constructor)
</li>
<li>Projections are generated automatically
</li>
<li>"Inheritance"
</li>
<li>Extensively used to formalize the algebraic hierarchy
</li>
<li>We can view them as <b>parametric modules</b>
</li>
</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">structure has_mul [class] (A : Type) :=
(mul : A → A → A)

structure semigroup [class] (A : Type) extends has_mul A :=
(mul_assoc : ∀a b c, mul (mul a b) c = mul a (mul b c))

...

structure group [class] (A : Type) extends monoid A, has_inv A :=
(mul_left_inv : ∀a, mul (inv a) a = one)
</juicy-ace-editor>
</div>

</section>
<section id="sec-19" >

<h2>Sylow theorem</h2>
<ul class="org-ul">
<li><a href="http://htzh.github.io/problemdriven/posts/Sylow.html">Developed by Haitao Zhang</a>
</li>
<li><a href="https://github.com/leanprover/lean/blob/master/library/theories/group_theory/group_theory.md">Available in the standard library</a>
</li>
</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables {A : Type} [ambA : group A] [finA : fintype A]
	  [deceqA : decidable_eq A]
include ambA deceqA finA

theorem cauchy_theorem
: ∀ p, prime p → p ∣ card(A) → ∃ g : A, order(g) = p

theorem first_sylow_theorem :
∀ p, prime p → ∀ n, p^n ∣ card(A) →
  ∃ (H : finset A) (sg : is_finsubg H), card(H) = p^n
</juicy-ace-editor>
</div>

</section>
<section id="sec-20" >

<h2>Category Theory</h2>
<ul class="org-ul">
<li>Developed by Floris van Doorn and Jakob von Raumer
</li>
<li><a href="https://github.com/leanprover/lean/blob/master/hott/algebra/category/category.md">In the HoTT library</a>
</li>
</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">theorem yoneda_embedding (C : Precategory) : C ⇒ set ^c Cᵒᵖ

theorem contravariant_yoneda_embedding (C : Precategory) : Cᵒᵖ ⇒ set ^c C
</juicy-ace-editor>
</div>

</section>
<section id="sec-21" >

<h2>Future work</h2>
<ul class="org-ul">
<li><b>Auto</b> tactic based on equational reasoning, matching, heuristic instantiation, &#x2026;
</li>
<li><b>Decision procedures</b> for arithmetic
</li>
<li>Efficient evaluator
</li>
<li>Better support for <b>proof by reflection</b>
</li>
<li>Better libraries (ongoing work)
</li>
<li>Machine learning
</li>
</ul>

</section>
<section id="sec-22" >

<h2>Thank you</h2>
<ul class="org-ul">
<li>Website: <a href="http://leanprover.github.io/">http://leanprover.github.io/</a>
</li>
<li>Source code: <a href="https://github.com/leanprover/lean">https://github.com/leanprover/lean</a>
</li>
<li>Theorem proving in Lean: <a href="https://leanprover.github.io/tutorial/index.html">https://leanprover.github.io/tutorial/index.html</a>
</li>
</ul>
</section>
</div>
</div>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-59814431-1', 'auto');ga('send', 'pageview');</script>

<script src="//leanprover.github.io/presentations/reveal.js-3.0.0/lib/js/head.min.js"></script>
<script src="//leanprover.github.io/presentations/reveal.js-3.0.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: false,
slideNumber: true,
rollingLinks: false,
keyboard: true,
overview: true,
width: 1000,
height: 800,
minScale: 1.00,
maxScale: 1.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
]
});
</script>
</body>
</html>
