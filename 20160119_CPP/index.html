<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>The Lean Theorem Prover <br> and <br> Automation</title>
<meta name="author" content="((link (:type http :path //leodemoura.github.io :raw-link http://leodemoura.github.io :application nil :search-option nil :begin 1 :end 72 :contents-begin 32 :contents-end 70 :post-blank 0 :parent #0) Leonardo de Moura (Microsoft Research)))"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="//leanprover.github.io/presentations/reveal.js-3.0.0/css/reveal.css"/>
<link rel="stylesheet" href="//leanprover.github.io/presentations/reveal.js-3.0.0/css/theme/soonho.css" id="theme"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '//leanprover.github.io/presentations/reveal.js-3.0.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/snap.svg/0.3.0/snap.svg-min.js"></script>
<script type="text/javascript">MathJax.Hub.Config({"HTML-CSS": {scale: 80 }})</script>
<script src="//cdn.jsdelivr.net/polymer.platform/0.4.2/platform.js"></script>
<link rel="import" href="./juicy-ace-editor.html">
<link rel="stylesheet" href="../css/code.css">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 id='title-name'>The Lean Theorem Prover <br> and <br> Automation</h1>
<h2 id='author-list'><a href="http://leodemoura.github.io/">Leonardo de Moura (Microsoft Research)</a></h2>
<h2 id='date'>CPP, 2016/01/19 <br> <a href="http://leanprover.github.io/">http://leanprover.github.io/</a></h2>
</section>

<section>
<section id="slide-orgheadline1">
<h2 id="orgheadline1">The Lean Theorem Prover Team</h2>
<ul>
<li>Soonho Kong (CMU),</li>
<li>Jeremy Avigad (CMU)</li>
<li>Floris van Doorn (CMU),</li>
<li>Rob Lewis (CMU),</li>
<li>Jakob von Raumer (KIT),</li>
<li>Daniel Selsam (Stanford)</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline2">
<h2 id="orgheadline2">Many thanks to</h2>
<ul>
<li>Cody Roux</li>
<li>Georges Gonthier</li>
<li>Grant Passmore</li>
<li>Nikhil Swamy</li>
<li>Assia Mahboubi</li>
<li>Bas Spitters</li>
<li>Steve Awodey</li>
<li>Ulrik Buchholtz</li>
<li>Tom Ball</li>
<li>Parikshit Khanna</li>
<li>Haitao Zhang</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline3">
<h2 id="orgheadline3">Introduction: <b>Lean</b></h2>
<ul>
<li>New <b>open source</b> theorem prover</li>
<li>Platform for
<ul>
<li><b>Software</b> verification &amp; development</li>
<li>Formalized <b>mathematics</b></li>
<li><b>Education</b> (mathematics, logic, computer science)</li>
<li><b>Synthesis</b> (proofs &amp; programs)</li>

</ul></li>
<li>de Bruijn's Principle: <b>small trusted kernel</b></li>
<li>Expressive logic</li>
<li>Partial constructions: automation fills the "holes"</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline4">
<h2 id="orgheadline4">Introduction: <b>Lean</b></h2>
<ul>
<li>Backend for other systems
<ul>
<li><a href="https://github.com/GaloisInc/lean-haskell-bindings">Haskell API for Lean</a> developed by Joe Hendrix</li>

</ul></li>
<li><a href="http://leanprover.github.io/tutorial">Interactive theory proving course</a> at CMU</li>
<li><a href="https://leanprover.github.io/logic_and_proof/">Introduction to Logic course</a> at CMU</li>
<li>It is an ongoing and <b>long long term</b> effort</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline5">
<h2 id="orgheadline5">Main Goal</h2>
<p>
<b>Lean aims to bring two worlds together</b>
</p>

<ul>
<li>An interactive theorem prover with powerful automation</li>
<li>An automated reasoning tool that
<ul>
<li>produces (detailed) proofs,</li>
<li>has a rich language,</li>
<li>can be used interactively, and</li>
<li>is built on a verified mathematical library</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline6">
<h2 id="orgheadline6">Secondary Goals</h2>
<ul>
<li><b>Robust proofs</b></li>

<li><b>Minimalist</b> and <b>high-performace</b> kernel</li>

<li><b>Education</b>
<ul>
<li>Interactive courses</li>
<li><b>Proving</b> should be as easy as <b>programming</b></li>

</ul></li>

<li><b>Have Fun</b></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline7">
<h2 id="orgheadline7">Software verification and <br> Formalized Mathematics</h2>
<ul>
<li>Some projects at Microsoft Research
<ul>
<li><a href="http://link.springer.com/chapter/10.1007/978-3-642-05089-3_51">Verifying the Microsoft Hyper-V Hypervisor using VCC</a></li>
<li><a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-hawblitzel.pdf">Ironclad: automated full-system verification</a></li>
<li><a href="http://delivery.acm.org/10.1145/2050000/2043197/p123-yang.pdf?ip=38.100.136.98&amp;id=2043197&amp;acc=OPEN&amp;key=4D4702B0C3E38B35.4D4702B0C3E38B35.4D4702B0C3E38B35.6D218144511F3437&amp;CFID=693556887&amp;CFTOKEN=63174865&amp;__acm__=1437010868_4af7dfc020206ac3436fa61ca1c3ff9c">Automated Verification of a Type-Safe Operating System</a></li>
<li><a href="http://www.ams.org/notices/200811/tx081101382p.pdf">Four-color theorem</a></li>
<li><a href="http://www.msr-inria.fr/news/feit-thomson-proved-in-coq/">Feit Thompson theorem</a></li>

</ul></li>
<li>Disclaimer: <b>this projects were developed before Lean existed</b></li>
<li>They used Boogie/Z3 and Coq.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline8">
<h2 id="orgheadline8">Software verification and <br> Formalized Mathematics</h2>
<ul>
<li>Similar problems
<ul>
<li><b>Proof stability</b></li>
<li>Libraries are big</li>
<li><b>Scalability</b> issues</li>
<li>Finding existing functions/theorems</li>

</ul></li>

<li>Common problems in software engineering:
<ul>
<li>Every attempt to create a single unified language failed (ADA?)</li>
<li>We keep reimplementing the same libraries over and over again</li>
<li>Mixing libraries from different languages is usually a mess</li>
<li><b>Bit rotting</b></li>

</ul></li>

<li>These problems also affect formalized mathematics</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline9">
<h2 id="orgheadline9">What is new?</h2>
<ul>
<li>Poweful <b>elaboration engine</b> that can handle
<ul>
<li>Higher-order unification</li>
<li>Definitional reductions</li>
<li>Coercions</li>
<li>Ad-hoc polymorphism (aka overloading)</li>
<li>Type classes</li>
<li>Tactics</li>

</ul></li>

</ul>

<blockquote nil>
<p>
"By relieving the brain of all unnecessary work, a good notation sets it free to
 concentrate on more advanced problems, and in effect increases the mental power of the
 race."
     &#x2013; A. N. Whitehead
</p>
</blockquote>

</section>
</section>
<section>
<section id="slide-orgheadline10">
<h2 id="orgheadline10">What is new?</h2>
<ul>
<li>Poweful <b>elaboration engine</b> that can handle</li>
<li>Small <b>trusted</b> kernel
<ul>
<li>It does <b>not</b> contain
<ul>
<li>Termination checker</li>
<li>Fixpoint operators</li>
<li>Pattern matching</li>
<li>Module management</li>

</ul></li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline11">
<h2 id="orgheadline11">What is new?</h2>
<ul>
<li>Poweful <b>elaboration engine</b> that can handle</li>
<li>Small <b>trusted</b> kernel</li>
<li>Multi-core support
<ul>
<li>Process theorems in parallel</li>
<li>Execute/try tactics (automation) in parallel</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline12">
<h2 id="orgheadline12">What is new?</h2>
<ul>
<li>Poweful <b>elaboration engine</b> that can handle</li>
<li>Small <b>trusted</b> kernel</li>
<li>Multi-core support</li>
<li>Fast <b>incremental compilation</b></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline13">
<h2 id="orgheadline13">What is new?</h2>
<ul>
<li>Poweful <b>elaboration engine</b> that can handle</li>
<li>Small <b>trusted</b> kernel</li>
<li>Multi-core support</li>
<li>Fast <b>incremental compilation</b></li>
<li>Support for <b>mixed</b> declarative and tactic <b>proof style</b></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline14">
<h2 id="orgheadline14">What is new?</h2>
<ul>
<li>Poweful <b>elaboration engine</b> that can handle</li>
<li>Small <b>trusted</b> kernel</li>
<li>Multi-core support</li>
<li>Fast <b>incremental compilation</b></li>
<li>Support for <b>mixed</b> declarative and tactic <b>proof style</b></li>
<li><b>Automation</b></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline15">
<h2 id="orgheadline15">Dependent Type Theory</h2>
<ul>
<li>Before we started Lean, we have studied different theorem
provers: ACL2, Agda, Automath, Coq, HOL (family), Isabelle, Mizar, PVS</li>

<li><b>Dependent type theory</b> is really <b>beautiful</b></li>

<li>Some advantages
<ul>
<li>Bultin computational interpretation</li>
<li>Same data-structure for representing proofs and terms</li>
<li>Reduce code duplication, example:
<ul>
<li>We implemented a compiler for Haskell-like recursive equations,
we can use it to construct proofs by induction</li>

</ul></li>
<li>Mathematical structures (such as Groups and Rings) are first-class citizens</li>

</ul></li>

<li>Some references
<ul>
<li><a href="https://golem.ph.utexas.edu/category/2010/03/in_praise_of_dependent_types.html">In praise of dependent types</a> (Mike Shulman)</li>
<li><a href="http://arxiv.org/pdf/1111.5885v2.pdf">Type inference in mathematics</a> (Jeremy Avigad)</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline16">
<h2 id="orgheadline16">Architecture</h2>

<div class="figure">
<p><img src="./img/framework1.png" alt="framework1.png" height="600px" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline17">
<h2 id="orgheadline17">Architecture</h2>

<div class="figure">
<p><img src="./img/framework2.png" alt="framework2.png" height="600px" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline18">
<h2 id="orgheadline18">Kernel</h2>
<ul>
<li>Kernel is implemented in two layers for easy customization</li>

<li><p>
1st layer, dependent lambda calculus + options:
</p>
<ul>
<li>Proof irrelevance</li>
<li>Impredicative Prop</li>

</ul>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">Π (x : nat), x = x  -- is a Proposition
∀ (x : nat), x = x  -- Alternative notation
</juicy-ace-editor>
</div></li>

<li>2nd layer: Inductive families, Quotient types, HITs</li>

</ul>


<div class="figure">
<p><img src="./img/kernel.png" alt="kernel.png" height="300px" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline19">
<h2 id="orgheadline19">Two official libraries</h2>
<ul>
<li><b>Standard</b>
<ul>
<li>Proof irrelevant and impredicative Prop</li>
<li>Smooth transition to classical logic</li>
<li>Inductive Families</li>
<li>Quotient Types</li>

</ul></li>

<li><b>HoTT</b>
<ul>
<li>Proof relevant and no impredicative Prop</li>
<li>Univalence axiom</li>
<li>Inductive Families</li>
<li>HIT</li>

</ul></li>

<li>Easy to implement experimental versions,
Example: <a href="https://github.com/leanprover/lean/issues/523">Steve Awodey asked for proof relevant and impredicative universe</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline20">
<h2 id="orgheadline20">Agnostic Mathematics</h2>
<ul>
<li>Support <b>constructive</b> and <b>classical</b> mathematics</li>
<li>Computation is important to mathematics</li>

<li><b>Core</b> parts of the standard library are <b>constructive</b></li>

<li><b>Separation of concerns</b>:
<ul>
<li>Methods to write computer programs</li>
<li>Freedom to use a nonconstructive theories and methods to reason about them</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline21">
<h2 id="orgheadline21">Noncomputable Keyword</h2>
<ul>
<li>Our conjecture: most users don't care about constructivism, what they really care about is whether code can be generated our not for a definition.</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">private noncomputable definition pb {s : seq} (Hs : regular s)
				    (Hpos : pos s) :=
  some (abs_pos_of_nonzero Hs (sep_zero_of_pos Hs Hpos))

private noncomputable definition ps {s : seq} (Hs : regular s)
				    (Hsep : sep s zero) :=
  some (abs_pos_of_nonzero Hs Hsep)

noncomputable definition s_inv {s : seq} (Hs : regular s) (n : ℕ+) : ℚ :=
  if H : sep s zero then
      (if n &lt; (ps Hs H) then 1 / (s ((ps Hs H) * (ps Hs H) * (ps Hs H)))
	else 1 / (s ((ps Hs H) * (ps Hs H) * n)))
  else 0
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline22">
<h2 id="orgheadline22"><b>Freedom to trust</b></h2>
<ul>
<li>Option: type check imported modules.</li>

<li><b>Macros</b>: semantic attachments for speeding up type checking and evaluation.</li>
<li>Macros can be eliminated (expanded into pure Lean code).</li>
<li>Each macro provides a function for computing the type and evaluating an instance.</li>
<li>Each macro can be assigned a <b>trust level</b>.</li>
<li>Many applications: interface with the GNU multiprecision arithmetic (GMP) library.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline23">
<h2 id="orgheadline23">Freedom to trust</h2>
<ul>
<li><b>Relaxed</b> mode

<ul>
<li>Trust the imported modules have not been tampered</li>
<li>Trust all macros</li>

</ul></li>

<li><b>Paranoid</b> mode

<ul>
<li>Retype check all imported modules (someone may have changed the binaries)</li>
<li>Expand all macros (the developers may have made mistakes, GMP may be buggy)</li>

</ul></li>

<li><b>Stronger guarantee</b> Retype check everything using Lean reference type checker

<ul>
<li>Daniel Selsam implemented a <a href="https://github.com/leanprover/tc">reference type checker</a> in Haskell</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline24">
<h2 id="orgheadline24">Exporting libraries</h2>
<ul>
<li>All Lean files can be exported in a very simple format</li>

<li><a href="https://github.com/leanprover/lean/blob/master/doc/export_format.md">Documentation is available on github</a></li>

<li>Communicate with other tools</li>

<li>Interface with the <a href="https://github.com/leanprover/tc">Lean reference type checker</a></li>

<li><a href="https://github.com/GaloisInc/lean-haskell-bindings">Haskell API</a> can be used to import libraries, browse and construct terms, parse files, etc.</li>

<li><a href="https://github.com/leanprover/lean/tree/master/src/api">We also have a C API</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline25">
<h2 id="orgheadline25">Recursive equations</h2>
<ul>
<li><b>Recursors</b> are <b>inconvenient</b> to use.</li>
<li>Compiler from <b>recursive equations</b> to <b>recursors</b>.</li>
<li>Two compilation strategies: <b>structural</b> and <b>well-founded</b> recursion</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">definition fib : nat → nat
| fib 0     := 1
| fib 1     := 1
| fib (a+2) := fib (a+1) + fib a

example (a : nat) : fib (a+2) = fib (a+1) + fib a :=
rfl
</juicy-ace-editor>
</div>

<ul>
<li>Proofs by induction</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline26">
<h2 id="orgheadline26">Recursive equations</h2>
<ul>
<li>Dependent pattern matching</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">definition map {A B C : Type} (f : A → B → C)
     : Π {n : nat}, vector A n → vector B n → vector C n
| map nil     nil     := nil
| map (a::va) (b::vb) := f a b :: map va vb

definition zip {A B : Type}
     : Π {n}, vector A n → vector B n → vector (A × B) n
| zip nil nil         := nil
| zip (a::va) (b::vb) := (a, b) :: zip va vb
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline27">
<h2 id="orgheadline27">Human-readable proofs</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">import algebra.category
open eq.ops category functor natural_transformation

variables {ob₁ ob₂ : Type} {C : category ob₁}
	  {D : category ob₂} {F G H : C ⇒ D}
definition nt_compose (η : G ⟹ H) (θ : F ⟹ G) : F ⟹ H :=
natural_transformation.mk
  (take a, η a ∘ θ a)
  (take a b f, calc
    H f ∘ (η a ∘ θ a) = (H f ∘ η a) ∘ θ a : assoc
		  ... = (η b ∘ G f) ∘ θ a : naturality
		  ... = η b ∘ (G f ∘ θ a) : assoc
		  ... = η b ∘ (θ b ∘ F f) : naturality
		  ... = (η b ∘ θ b) ∘ F f : assoc
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline28">
<h2 id="orgheadline28">Tactics</h2>
<ul>
<li>Automation such as rewrite engined, simplifiers and decision procedures are integrated into
the system as tactics.</li>
<li>A placeholder/hole can be viewed as a <b>goal</b></li>
<li>A <b>proof state</b> is a sequence of goals, substitution (already solved holes), and postponed constraints.</li>
<li>A <b>tactic</b> is a function from proof state to a <b>lazy stream of proof states</b> (very similar to Isabelle).</li>
<li><b>Tacticals</b> are tactic combinadors: <b>andthen</b>, <b>orelse</b>, <b>par</b>, &#x2026;</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline29">
<h2 id="orgheadline29">Structures</h2>
<ul>
<li>Special kind of inductive datatype (only one constructor)</li>
<li>Projections are generated automatically</li>
<li>"Inheritance"</li>
<li>Extensively used to formalize the algebraic hierarchy</li>
<li>We can view them as <b>parametric modules</b></li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">structure has_mul [class] (A : Type) :=
(mul : A → A → A)

structure semigroup [class] (A : Type) extends has_mul A :=
(mul_assoc : ∀a b c, mul (mul a b) c = mul a (mul b c))

...

structure group [class] (A : Type) extends monoid A, has_inv A :=
(mul_left_inv : ∀a, mul (inv a) a = one)
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline30">
<h2 id="orgheadline30">Structures</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">structure ring [class] (A : Type)
   extends add_comm_group A, monoid A, distrib A

variable {A : Type}

theorem ring.mul_zero [s : ring A] (a : A) : a * 0 = 0 :=
have H : a * 0 + 0 = a * 0 + a * 0, from calc
 a * 0 + 0 = a * 0      : by simp
    ... = a * (0 + 0)   : by simp
    ... = a * 0 + a * 0 : by simp
show a * 0 = 0,   by simp
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline31">
<h2 id="orgheadline31">Structures (additional instances)</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">structure ring [class] (A : Type)
   extends add_comm_group A, monoid A, distrib A

variable {A : Type}

theorem ring.mul_zero [s : ring A] (a : A) : a * 0 = 0 := ...
theorem ring.zero_mul [s : ring A] (a : A) : 0 * a = 0 := ...

definition ring.to_semiring [instance] [s : ring A] : semiring A :=
⦃ semiring, s,
  mul_zero := ring.mul_zero,
  zero_mul := ring.zero_mul ⦄
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline32">
<h2 id="orgheadline32">Structures (concrete instances)</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">protected definition int.linear_ordered_comm_ring [instance] :
  algebra.linear_ordered_comm_ring int :=
⦃algebra.linear_ordered_comm_ring, int.integral_domain,
  le               := int.le,
  le_refl          := int.le.refl,
  le_trans         := int.le.trans,
  le_antisymm      := int.le.antisymm,
  lt               := int.lt,
  le_of_lt         := int.le_of_lt,
  lt_irrefl        := int.lt.irrefl,
  ...
  le_iff_lt_or_eq  := int.le_iff_lt_or_eq,
  le_total         := int.le.total,
  zero_ne_one      := int.zero_ne_one,
  zero_lt_one      := int.zero_lt_one,
  add_lt_add_left  := int.add_lt_add_left⦄
</juicy-ace-editor>
</div>

<ul>
<li>Is <code>int</code> a <code>add_group</code>? <b>Yes</b></li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">int.linear_ordered_comm_ring   :  algebra.linear_ordered_comm_ring int
linear_ordered_comm_ring int   → comm_ring int
comm_ring int                  → ring int
ring int                       → add_comm_group int
add_comm_group int             → add_group int
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline33">
<h2 id="orgheadline33">Sylow theorem</h2>
<ul>
<li><a href="http://htzh.github.io/problemdriven/posts/Sylow.html">Developed by Haitao Zhang</a></li>
<li><a href="https://github.com/leanprover/lean/blob/master/library/theories/group_theory/group_theory.md">Available in the standard library</a></li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables {A : Type} [group A] [fintype A]
	  [decidable_eq A]
include ambA deceqA finA

theorem cauchy_theorem
: ∀ p, prime p → p ∣ card(A) → ∃ g : A, order(g) = p

theorem first_sylow_theorem :
∀ p, prime p → ∀ n, p^n ∣ card(A) →
  ∃ (H : finset A) (sg : is_finsubg H), card(H) = p^n
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline34">
<h2 id="orgheadline34">Automation in Lean</h2>
<ul>
<li>Joint work with Daniel Selsam (Stanford)</li>
<li><b>Work in Progress</b></li>
<li>Collection of proof procedures
<ul>
<li>Congruence closure</li>
<li>E-matching</li>
<li>Arithmetic</li>
<li>Ordered rewriting</li>
<li>Completion and superposition calculus</li>

</ul></li>
<li>SMT/ATP procedures for dependent type theory.</li>
<li><b>Indexing</b></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline35">
<h2 id="orgheadline35">Automation (main challenges)</h2>
<ul>
<li>Many different settings
<ul>
<li>Constructive vs <b>Classical</b></li>
<li>Semi-constructive axioms: <b>propext</b>, <b>quotients/funext</b></li>
<li>Proof relevant vs <b>proof irrelevant</b></li>
<li><b>Impredicative Prop</b></li>

</ul></li>

<li>Dependent types</li>

<li>Type classes</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">theorem mul.assoc [semigroup A] (a b c : A) : a * b * c = a * (b * c)
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline36">
<h2 id="orgheadline36">Congruence closure</h2>
<ul>
<li>It is in the kernel of most SMT solvers (e.g., CVC4, MathSAT, Yices, Z3)</li>

<li>Efficient procedure for equality</li>

</ul>


<div class="figure">
<p><img src="./img/cc1.png" alt="cc1.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline37">
<h2 id="orgheadline37">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc2.png" alt="cc2.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline38">
<h2 id="orgheadline38">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc3.png" alt="cc3.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline39">
<h2 id="orgheadline39">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc4.png" alt="cc4.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline40">
<h2 id="orgheadline40">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc5.png" alt="cc5.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline41">
<h2 id="orgheadline41">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc6.png" alt="cc6.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline42">
<h2 id="orgheadline42">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc7.png" alt="cc7.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline43">
<h2 id="orgheadline43">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc8.png" alt="cc8.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline44">
<h2 id="orgheadline44">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc9.png" alt="cc9.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline45">
<h2 id="orgheadline45">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc10.png" alt="cc10.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline46">
<h2 id="orgheadline46">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc11.png" alt="cc11.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline47">
<h2 id="orgheadline47">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc12.png" alt="cc12.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline48">
<h2 id="orgheadline48">Congruence closure</h2>

<div class="figure">
<p><img src="./img/cc13.png" alt="cc13.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline49">
<h2 id="orgheadline49">Congruence closure + Heuristic instantiation</h2>
<ul>
<li>Heuristic instantiation: adds instances of lemmas to local context.</li>

<li>Simple and effective (used by many SMT solvers).</li>

<li>"Context as a black board".</li>

<li><b>Indexing</b>.</li>

<li>Avoids many technical issues.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline50">
<h2 id="orgheadline50">Congruence closure and dependent functions</h2>
<ul>
<li>Equality type</li>

</ul>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables A : Type
variables a b : A

a = b
-- is notation for
eq A a b
</juicy-ace-editor>
</div>

<ul>
<li>Congruence closure is easy for non-dependent functions.</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">lemma congr {A B : Type} {f g : A → B} {a b : A} :
      f = g → a = b → f a = g b
</juicy-ace-editor>
</div>

<ul>
<li>Dependent functions</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables (A : Type) (B : A → Type) (f : Π a : A, B a)
variables (a b : A)

-- The following equality is not type correct
check f a = f b
check f a : B a
check f b : B b
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline51">
<h2 id="orgheadline51">Casts</h2>
<ul>
<li>Cast operation</li>

</ul>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables (e : a = b) (t : B a)
check e ▸ t
-- e ▸ t : B b
</juicy-ace-editor>
</div>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">lemma dcongr {A : Type} {B : A → Type} {f g : Π a : A, B a} {a b : A}
	     (e₁ : f = g) (e₂ : a = b) : e₂ ▸ (f a) = g b
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline52">
<h2 id="orgheadline52">Heterogeneous equality</h2>
<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables A B : Type
variables a : A
variables b : B

a == b
-- is notation for
heq A a B b
</juicy-ace-editor>
</div>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">lemma dcongr {A : Type} {B : A → Type} {f g : Π a : A, B a} {a b : A}
	     (e₁ : f = g) (e₂ : a = b) : f a == g b
</juicy-ace-editor>
</div>

<ul>
<li>Heterogeneous to Homogeneous</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">variables A : Type
variables a b : A
a == b → a = b
-- We need UIP, K-axiom or proof irrelevance
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline53">
<h2 id="orgheadline53">Congruence for heterogeneous equality</h2>
<ul>
<li>Next problem: following lemma is not provable without assuming another axiom.</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">lemma hcongr {A A' : Type} {B : A → Type} {B' : A' → Type}
	     {f : Π a : A, B a}
	     {g : Π a : A', B' a}
	     {a : A} {b : A'} :
	     f == g → a == b → f a == g b
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline54">
<h2 id="orgheadline54">Congruence for heterogeneous equality</h2>
<ul>
<li>BUT, the following family of lemmas is</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">lemma hcongr_n
      {A₁ : Type}
      {A₂ : A₁ → Type}
      ...
      (f g: Π a_1 ... a_n, B a_1 ... a_n) :
      f = g → a_1 == b_1 → ... → a_n == b_n →
      f a_1 ... a_n == f b_1 ... b_n
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline55">
<h2 id="orgheadline55">Example</h2>
<ul>
<li>Induction + Congruence closure + Heuristic instantiation is
already quite useful.</li>

</ul>

<div class="org-src-container">

<juicy-ace-editor mode="ace/mode/lean" theme="ace/theme/chrome" fontsize="20px">inductive vector (A : Type) : nat → Type :=
| nil {} : vector A zero
| cons   : Π {n}, A → vector A n → vector A (succ n)

definition append : Π {n m : nat}, vector A n → vector A m → vector A (n + m)
| 0        m []     w := w
| (succ n) m (a::v) w := a :: (append v w)

notation ⟨ a ⟩ := cast (by blast) a

definition reverse : Π {n : nat}, vector A n → vector A n
| 0     []        := []
| (succ n) (x :: xs) := ⟨ reverse xs ++ [x] ⟩

theorem reverse_reverse : ∀ {n : nat} (v : vector A n),
	    reverse (reverse v) = v :=
by blast

theorem reverse_append : ∀ {n m : nat} (v : vector A n) (w : vector A m),
	reverse (append v w) == append (reverse w) (reverse v) :=
by blast
</juicy-ace-editor>
</div>

</section>
</section>
<section>
<section id="slide-orgheadline56">
<h2 id="orgheadline56">Congruence closure and proof relevance</h2>
<ul>
<li>In HoTT mode (proof relevant), the previous solution doesn't work.</li>
<li>No general solution so far.</li>
<li>The basic idea is the same: <b>generate custom congruence lemmas</b>.</li>
<li>We can handle many <b>special cases</b>.</li>
<li>Examples:
<ul>
<li>Indices are h-Sets (nat is a hSet).</li>
<li>Parameters that are mere propositions (h-Props) can be ignored.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline57">
<h2 id="orgheadline57">Future work</h2>
<ul>
<li>More automation</li>
<li>Efficient evaluator</li>
<li>Code generator</li>
<li>Better libraries (ongoing work)</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline58">
<h2 id="orgheadline58">Thank you</h2>
<ul>
<li>Website: <a href="http://leanprover.github.io/">http://leanprover.github.io/</a></li>
<li>Source code: <a href="https://github.com/leanprover/lean">https://github.com/leanprover/lean</a></li>
<li>Theorem proving in Lean: <a href="https://leanprover.github.io/tutorial/index.html">https://leanprover.github.io/tutorial/index.html</a></li>

</ul>
</section>
</section>
</div>
</div>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-59814431-1', 'auto');ga('send', 'pageview');</script>
<script src="//leanprover.github.io/presentations/reveal.js-3.0.0/lib/js/head.min.js"></script>
<script src="//leanprover.github.io/presentations/reveal.js-3.0.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: false,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1000,
height: 800,
minScale: 1.00,
maxScale: 1.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '//leanprover.github.io/presentations/reveal.js-3.0.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
